name: Deploy to PythonAnywhere

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # 獲取所有歷史記錄，幫助更好地檢測變更
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Prepare deployment
        run: |
          echo "==== 準備部署 ===="
          
          # 設置調試模式
          set -ex
          
          # 顯示工作空間根目錄
          echo "工作空間根目錄:"
          pwd
          
          # 創建一個簡單的部署文件列表（除了cache和data目錄）
          echo "創建部署文件列表..."
          find . -type f \
            -not -path "*/\.*" \
            -not -path "*/venv/*" \
            -not -path "*/cache/*" \
            -not -path "*/__pycache__/*" \
            -not -path "*/app/data/*" \
            > deploy_files.txt
          
          # 顯示將要部署的文件數量和類型
          echo "將部署 $(wc -l < deploy_files.txt) 個文件"
          echo "HTML文件數量: $(grep -c "\.html$" deploy_files.txt)"
          echo "Python文件數量: $(grep -c "\.py$" deploy_files.txt)"
          
          # 檢查關鍵文件是否在列表中
          echo "檢查關鍵文件..."
          for file in "app/templates/common/layout.html" "app/templates/japanese/index.html" "app/routes/japanese_routes.py"; do
            if grep -q "$file" deploy_files.txt; then
              echo "✅ $file 在部署列表中"
            else
              echo "❌ $file 不在部署列表中!"
            fi
          done
      
      - name: Deploy to PythonAnywhere
        run: |
          echo "==== 開始部署 ===="
          
          # 設置調試模式
          set -ex
          
          # 設定基本變量
          BASE_DIR="/home/${{ secrets.PA_USERNAME }}/learnflask"
          API_TOKEN="${{ secrets.PA_API_TOKEN }}"
          API_BASE="https://www.pythonanywhere.com/api/v0/user/${{ secrets.PA_USERNAME }}"
          
          # 步驟1: 收集目錄列表並確保所有目錄存在
          echo "創建所有必要的目錄..."
          DIRS=$(cat deploy_files.txt | xargs -I{} dirname {} | sort | uniq)
          echo "$DIRS" > directories.txt
          
          # 創建項目根目錄
          echo "創建項目根目錄: $BASE_DIR"
          curl -X POST "$API_BASE/files/path$BASE_DIR/" \
            -H "Authorization: Token $API_TOKEN" || true
          
          # 創建所有目錄，包括嵌套目錄
          cat directories.txt | while read dir; do
            # 跳過當前目錄
            if [ "$dir" = "." ]; then
              continue
            fi
            
            # 把相對路徑轉為 PythonAnywhere 上的絕對路徑
            remote_dir="$BASE_DIR/${dir#./}"
            echo "創建目錄: $remote_dir"
            
            # 創建目錄
            curl -X POST "$API_BASE/files/path$remote_dir/" \
              -H "Authorization: Token $API_TOKEN" || true
              
            # 添加延遲以避免達到 API 限制
            sleep 0.5
          done
          
          # 步驟2: 創建空的 data 和 cache 目錄
          echo "創建 data 和 cache 目錄..."
          for dir in app/data cache; do
            remote_dir="$BASE_DIR/$dir"
            echo "創建目錄: $remote_dir"
            curl -X POST "$API_BASE/files/path$remote_dir/" \
              -H "Authorization: Token $API_TOKEN" || true
            sleep 0.5
          done
          
          # 步驟3: 上傳所有文件，確保強制覆蓋
          echo "上傳所有文件..."
          TOTAL_FILES=$(wc -l < deploy_files.txt)
          COUNTER=0
          SUCCESS=0
          FAILED=0
          ERRORS_LOG=""
          TEMPLATES_LOG=""
          
          # 創建函數用於處理文件上傳
          upload_file() {
            local file=$1
            local remote_file="$BASE_DIR/${file#./}"
            
            # 首先強制刪除現有文件（如果存在）
            echo "刪除現有文件: $remote_file"
            curl -s -X DELETE "$API_BASE/files/path$remote_file" \
              -H "Authorization: Token $API_TOKEN" > /dev/null
              
            # 暫停以避免 API 速率限制
            sleep 0.5
              
            # 然後上傳新文件
            echo "上傳新文件: $file -> $remote_file"
            local status_code=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST "$API_BASE/files/path$remote_file" \
              -H "Authorization: Token $API_TOKEN" \
              -F "content=@$file" \
              -F "path=$remote_file")
              
            echo "$status_code"
          }
          
          retry_upload() {
            local file=$1
            local remote_file="$BASE_DIR/${file#./}"
            local retry_count=$2
            local sleep_time=$3
            
            echo "🔄 嘗試重新上傳 $file (嘗試 $retry_count)，等待 ${sleep_time}秒..."
            
            # 等待指定的時間 (指數退避策略)
            sleep $sleep_time
            
            # 強制刪除現有文件
            curl -s -X DELETE "$API_BASE/files/path$remote_file" \
              -H "Authorization: Token $API_TOKEN" > /dev/null 2>&1
              
            sleep 0.5
              
            # 使用詳細輸出進行調試
            local retry_status=$(curl -s -o /dev/null -w "%{http_code}" \
              -X POST "$API_BASE/files/path$remote_file" \
              -H "Authorization: Token $API_TOKEN" \
              -F "content=@$file" \
              -F "path=$remote_file")
            
            echo "$retry_status"
          }
          
          # 開始上傳所有文件，批次處理並添加延遲
          # 每上傳10個文件暫停5秒，避免速率限制
          BATCH_SIZE=5
          BATCH_COUNT=0
          
          cat deploy_files.txt | while read file; do
            # 更新計數器
            COUNTER=$((COUNTER+1))
            BATCH_COUNT=$((BATCH_COUNT+1))
            
            # 顯示進度
            echo "[$COUNTER/$TOTAL_FILES] 上傳文件: $file"
            
            # 上傳文件（使用改進的上傳函數確保覆蓋）
            STATUS_CODE=$(upload_file "$file")
              
            # 檢查上傳結果
            if [ "$STATUS_CODE" = "200" ] || [ "$STATUS_CODE" = "201" ]; then
              echo "✅ 文件上傳成功: $file (HTTP $STATUS_CODE)"
              SUCCESS=$((SUCCESS+1))
              
              # 特別記錄模板文件
              if [[ $file == *".html"* ]]; then
                TEMPLATES_LOG="$TEMPLATES_LOG\n$file"
              fi
            else
              # 如果遇到429錯誤（速率限制），使用指數退避策略重試
              if [ "$STATUS_CODE" = "429" ]; then
                echo "⚠️ 遇到速率限制: $file (HTTP 429)"
                
                # 第一次重試等待5秒
                echo "等待5秒後重試..."
                RETRY_STATUS=$(retry_upload "$file" 1 5)
                
                if [ "$RETRY_STATUS" = "200" ] || [ "$RETRY_STATUS" = "201" ]; then
                  echo "✅ 重試成功: $file (HTTP $RETRY_STATUS)"
                  SUCCESS=$((SUCCESS+1))
                elif [ "$RETRY_STATUS" = "429" ]; then
                  # 第二次重試等待15秒
                  echo "繼續遇到速率限制，等待15秒後重試..."
                  RETRY_STATUS=$(retry_upload "$file" 2 15)
                  
                  if [ "$RETRY_STATUS" = "200" ] || [ "$RETRY_STATUS" = "201" ]; then
                    echo "✅ 重試成功: $file (HTTP $RETRY_STATUS)"
                    SUCCESS=$((SUCCESS+1))
                  elif [ "$RETRY_STATUS" = "429" ]; then
                    # 第三次重試等待30秒
                    echo "繼續遇到速率限制，等待30秒後最後重試..."
                    RETRY_STATUS=$(retry_upload "$file" 3 30)
                    
                    if [ "$RETRY_STATUS" = "200" ] || [ "$RETRY_STATUS" = "201" ]; then
                      echo "✅ 最終重試成功: $file (HTTP $RETRY_STATUS)"
                      SUCCESS=$((SUCCESS+1))
                    else
                      echo "❌ 多次重試後仍然失敗: $file (HTTP $RETRY_STATUS)"
                      FAILED=$((FAILED+1))
                      ERRORS_LOG="$ERRORS_LOG\n$file (HTTP $RETRY_STATUS)"
                    fi
                  else
                    echo "❌ 重試失敗: $file (HTTP $RETRY_STATUS)"
                    FAILED=$((FAILED+1))
                    ERRORS_LOG="$ERRORS_LOG\n$file (HTTP $RETRY_STATUS)"
                  fi
                else
                  echo "❌ 重試失敗: $file (HTTP $RETRY_STATUS)"
                  FAILED=$((FAILED+1))
                  ERRORS_LOG="$ERRORS_LOG\n$file (HTTP $RETRY_STATUS)"
                fi
              else
                echo "❌ 文件上傳失敗: $file (HTTP $STATUS_CODE)"
                RETRY_STATUS=$(retry_upload "$file" 1 3)
                
                if [ "$RETRY_STATUS" = "200" ] || [ "$RETRY_STATUS" = "201" ]; then
                  echo "✅ 重試成功: $file (HTTP $RETRY_STATUS)"
                  SUCCESS=$((SUCCESS+1))
                else
                  FAILED=$((FAILED+1))
                  ERRORS_LOG="$ERRORS_LOG\n$file (HTTP $RETRY_STATUS)"
                  echo "❌ 重試失敗: $file (HTTP $RETRY_STATUS)"
                fi
              fi
            fi
            
            # 每上傳一批文件後暫停
            if [ "$BATCH_COUNT" -ge "$BATCH_SIZE" ]; then
              echo "已上傳 $BATCH_SIZE 個文件，暫停5秒避免速率限制..."
              sleep 5
              BATCH_COUNT=0
            else
              # 每個文件之間的輕微延遲
              sleep 0.5
            fi
          done
          
          # 清理 __pycache__ 和 .pyc 文件
          echo "清理 Python 緩存文件..."
          curl -X POST "$API_BASE/consoles/" \
            -H "Authorization: Token $API_TOKEN" \
            -d "executable=bash" \
            -d "arguments=" \
            -d "working_directory=/home/${{ secrets.PA_USERNAME }}/learnflask" \
            > console_response.json
          
          CONSOLE_ID=$(cat console_response.json | grep -o '"id":[^,]*' | cut -d':' -f2 | tr -d ' "')
          
          if [ ! -z "$CONSOLE_ID" ]; then
            echo "執行清理命令，Console ID: $CONSOLE_ID"
            # 等待控制台就緒
            sleep 2
            
            # 發送命令清理 __pycache__ 目錄和 .pyc 文件，但排除 data 和 cache 目錄
            curl -X POST "$API_BASE/consoles/$CONSOLE_ID/send_input/" \
              -H "Authorization: Token $API_TOKEN" \
              -d "input=find . -path \"*/app/data\" -prune -o -path \"*/cache\" -prune -o -name \"__pycache__\" -type d -exec rm -rf {} + 2>/dev/null || true"
              
            curl -X POST "$API_BASE/consoles/$CONSOLE_ID/send_input/" \
              -H "Authorization: Token $API_TOKEN" \
              -d "input=find . -path \"*/app/data\" -prune -o -path \"*/cache\" -prune -o -name \"*.pyc\" -delete"
          else
            echo "無法創建控制台，跳過清理步驟"
          fi
          
          # 驗證部署結果
          echo "驗證部署..."
          CRITICAL_DIRS="app/templates app/templates/auth app/templates/common app/templates/japanese app/routes"
          for dir in $CRITICAL_DIRS; do
            echo "列出 $dir 目錄內容:"
            curl -sS "$API_BASE/files/path$BASE_DIR/$dir/" \
              -H "Authorization: Token $API_TOKEN" 
            echo ""
            sleep 1  # 添加延遲避免速率限制
          done
          
          # 顯示部署統計
          echo "==== 部署統計 ===="
          echo "總共文件: $TOTAL_FILES"
          echo "成功上傳: $SUCCESS"
          echo "失敗上傳: $FAILED"
          if [ "$FAILED" -gt 0 ]; then
            echo -e "失敗的文件:$ERRORS_LOG"
          fi
          
          # 雙重保險：重新加載 Web 應用
          echo "重新加載 Web 應用..."
          # 方法1：使用 API 重新加載
          curl -X POST "$API_BASE/webapps/${{ secrets.PA_USERNAME }}.pythonanywhere.com/reload/" \
            -H "Authorization: Token $API_TOKEN"
            
          # 方法2：觸碰 WSGI 文件
          if [ ! -z "$CONSOLE_ID" ]; then
            echo "觸碰 WSGI 文件..."
            curl -X POST "$API_BASE/consoles/$CONSOLE_ID/send_input/" \
              -H "Authorization: Token $API_TOKEN" \
              -d "input=touch /var/www/${{ secrets.PA_USERNAME }}_pythonanywhere_com_wsgi.py"
          fi
            
          echo "部署完成!"
      
      - name: Final Cleanup
        if: always()
        run: |
          echo "清理完成，部署結束"

